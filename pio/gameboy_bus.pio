
.define public pin_clk         1
.define public pin_rd          2
.define public pin_a15        18
.define public pin_a14        17
.define public pin_a13         16
.define public pin_ad_base     4
.define public pin_data_base   20

; pins need to be shifted for internal use as PIO is set to upper pins

.define PIN_CLK_INT (pin_clk - 16)
.define PIN_A15_INT (pin_a15 - 16)

.program gameboy_bus_write_to_data
.wrap_target
    pull block                                 ; pull the data from the Tx FIFO into the OSR
    out  pins 8                               ; output 8 bits of data
    mov  osr ~null                             ; OSR=FFFFFFFF
    out  pindirs 8                             ; start driving the data bus
    wait 0 gpio PIN_CLK_INT                        ; wait for clk
    mov  osr null
    wait 1 gpio PIN_CLK_INT[3]                     ; wait for clk
    out  pindirs 8                          ; stop driving the data bus
    .wrap ; wrap back to beginning


.program gameboy_bus_detect_a15_low_a14_irqs
a14_high:
    irq set 1
.wrap_target
    wait 0 gpio PIN_CLK_INT
public entry_point:
    wait 1 gpio PIN_CLK_INT[2]
    mov  isr null
    in pins 1 ; shift in a15
    mov y isr ; store a15 pin in y
    jmp  !y hdma_read ; GBC has the HDMA read which does not strobe A15
    wait 0 gpio PIN_A15_INT
continue_hdma_read:
    jmp pin a14_high ; if A14 is high
    irq set 0 ; if a A14 is low
    .wrap
hdma_read:
    jmp continue_hdma_read [30]


.program gameboy_bus_rom_low
idle:
.wrap_target
    wait 1 irq 0 rel ; will wait on irq 0 on SM0 (low) and irq 1 on SM1 (high)
    jmp pin idle ; on reads back to idle

    in   pins 14         ; shift A0 to A13 pins into ISR and auto push
    .wrap


.program gameboy_bus_rom_high
idle:
.wrap_target
    wait 1 irq 0 rel ; will wait on irq 0 on SM0 (low) and irq 1 on SM1 (high)
    jmp pin idle ; on reads back to idle

    in   pins 14          ; shift A0 to A13 pins into ISR and auto push
    in null 8
    .wrap


